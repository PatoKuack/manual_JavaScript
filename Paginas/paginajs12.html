<!DOCTYPE html>
<html lang="es">
<head>
  <!-- No guardar cache en navegadores -->
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="expires" content="0">
  <!-- ------------------- -->
  <link rel="stylesheet" href="../Estilos/stylejs1.css">
  <link rel="stylesheet" href="../Estilos/stylejs2.css">
  <link rel="stylesheet" href="../Estilos/stylejs9.css">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ECMAScript6+</title>
</head>
<body>
  <div class="medio">
    <h2>ECMAScript6+</h2>
    <div>
      <p>ECMA es una institución que dicta estándares o funcionalidades que deben adaptarse o añadirse a los engines de Js. Puesto que Js es un lenguaje interpretado y con muchos motores que lo interpretan/compilan, se vio la necesidad de hacer un estándar que todos esos motores siguieran, para tener consistencia en nuestro desarrollo a lo largo de todos los navegadores.</p>
      <p>ECMAScript es la especificación del lenguaje JavaScript propuesto por ECMA Internacional.</p>
      <p>JavaScript es un lenguaje de programación o de secuencias de comandos que permite implementar funciones complejas en páginas web, este lenguaje utiliza las especificaciones propuestas por ECMA, que van siendo añadidas a ECMAScript cada año a partir del 2015, cuando fue lanzado ES6.</p>
      <p>La especificación ECMA-262 de ECMASCRIPT es un manual de más de 800 páginas que muestra todo acerca del lenguaje JavaScript.</p>
    </div>
    <div>
      <p>En ECMAScript 6 se agregaron varias características:</p>
      <h3>Parámetros por defecto.</h3>
      <p>Permiten establecer los valores por defecto que se le pasan a una función.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejDefault" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeDefault">
        function newFunction(name, age){<br/>
        var name = name || 'Fulanito';<br/>
        var age = age || 18;<br/>
        console.log(name, age);<br/>
        }<br/>
        newfunction(); <em class="coment">// imprime los valore por defecto: Fulanito 18</em><br/>
        newfunction('Luis', 22); <em class="coment">// imprime los valores establecidos: Luis 22</em><br/>
      </span>
      <span class="ejAfter blind" id="ejAfterDefault">
        function newFunction(name = 'Fulanito', age = 18){<br/>
        console.log(name, age);<br/>
        }<br/>
        newfunction(); <em class="coment">// imprime los valore por defecto: Fulanito 18</em><br/>
        newfunction('Luis', 22); <em class="coment">// imprime los valores establecidos: Luis 22</em><br/>
      </span>
      <h3>Template literals.</h3>
      <p>Permiten separar o unir varios elementos.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejLiteral" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeLiteral">
        let im = "Soy";<br/>
        let a = "un";<br/>
        let goofyGoober = "cacahuate";<br/>
        let epicPhrase = im + ' ' + a + ' ' + goofyGoober; <em class="coment">// concatenación de valores con el signo +.</em><br/>
        console.log(epicPhrase);
      </span>
      <span class="ejAfter blind" id="ejAfterLiteral">
        let im = "Soy";<br/>
        let a = "un";<br/>
        let goofyGoober = "cacahuate";<br/>
        let epicPhrase = `${im} ${a} ${goofyGoober}`; <em class="coment">// concatenación de valores con template literals ``.</em><br/>
        console.log(epicPhrase);
      </span>
      <h3>Multilínea en strings.</h3>
      <p>Permite agregar saltos de línea en las declaraciones de tipo string.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejMultilinea" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeMultilinea">
        let mathProblem = "Si le das la mitad de tu manzana a un amigo, ¿Qué tienes? \n u... un amigo"; <em class="coment">// Se requiere un slash invertido con una ene para que se produzca un salto de línea en el string.</em><br/>
        console.log(mathProblem);<br/>
      </span>
      <span class="ejAfter blind" id="ejAfterMultilinea">
        let mathProblem = `Si le das la mitad de tu manzana a un amigo, ¿Qué tienes?<br/>
        u... un amigo`; <em class="coment">// Solo se requiere un salto de línea para que se visualice en el string.</em><br/>
        console.log(mathProblem);
      </span>
      <h3>Restructuración de elementos.</h3>
      <p>Permite acceder y restructurar elementos de un objeto.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejRestruct" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeRestruct">
        let person = {<br/>
          'name': 'oscar';<br/>
          'age':  '32';<br/>
        }<br/>
        console.log(person.name, person.age); <em class="coment">// Imprime los elementos de una forma un poco compleja, pero con un método fácil de recordar.</em>
      </span>
      <span class="ejAfter blind" id="ejAfterRestruct">
        let person = {<br/>
          'name': 'oscar';<br/>
          'age':  '32';<br/>
        }<br/>
        let { name, age } = person;<br/>
        console.log(name, age); <em class="coment">// Imprime los elementos de una forma menos compleja, pero con un método más difícil de recordar.</em>
      </span>
      <h3>Operador de propagación.</h3>
      <p>Permite importar los elementos de un objeto.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejOPropaga" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeOPropaga">
        let team1 = ['Vilma', 'Scooby', 'Shaggy'];<br/>
        let team2 = ['Daphne', 'Fred'];<br/>
        let mistery = ['Scrappy', 'Vilma', 'Scooby', 'Shaggy', 'Daphne', 'Fred']; <em class="coment">// Conjunto de los equipos de una forma laboriosa.</em><br/>
        console.log(mistery);
      </span>
      <span class="ejAfter blind" id="ejAfterOPropaga">
        let team1 = ['Vilma', 'Scooby', 'Shaggy'];<br/>
        let team2 = ['Daphne', 'Fred'];<br/>
        let mistery = ['Scrappy', ...team1, ...team2]; <em class="coment">// Conjunto de los equipos de una forma más fácil.</em><br/>
        console.log(mistery);
      </span>
      <h3>Propiedad de objetos mejorada.</h3>
      <p>Permite trabajar con objetos de una forma más fácil al querer asignarles valores a sus elementos.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejObjeto" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeObjeto">
        let monster = 'Ickis';<br/>
        let reportCard = 7;<br/>
        school = { monster: monster, reportCard: reportCard }; <em class="coment">// Establece elementos para un objeto tomando variables para ello.</em><br/>
        console.log(school);<br/>
      </span>
      <span class="ejAfter blind" id="ejAfterObjeto">
        let monster = 'Ickis';<br/>
        let reportCard = 7;<br/>
        school = { monster, reportCard }; <em class="coment">// Establece elementos para un objeto tomando variables para ello de una forma simple.</em><br/>
        console.log(school);<br/>
      </span>
      <h3>Arrow Function / Funciones de flecha.</h3>
      <p>Permite tener una sintaxis más reducida y un <b>this</b> no vinculable.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejArrow" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeArrow">
        const names = [<br/>
          { name: 'Oscar', age: 32}<br/>
          { name: 'Brandon', age: 22}<br/>
        ]<br/>
        let listOfNames = names.map (<br/>
          function ( item ) {<br/>
            console.log( item.name ); <em class="coment">// Imprime cada uno de los nombres del objeto.</em><br/>
        } )<br/>
      </span>
      <span class="ejAfter blind" id="ejAfterArrow">
        const names = [<br/>
          { name: 'Oscar', age: 32}<br/>
          { name: 'Brandon', age: 22}<br/>
        ]<br/>
        let listOfNames = names.map ( item => {<br/>
          console.log( item.name ); <em class="coment">// Se establece como una función anónima que retornará cada uno de los nombres del objeto.</em><br/>
        } )<br/>
      </span>
      <h3>Promesas.</h3>
      <p>Permite trabajar con el asincronismo de JavaScript (asincronismo se refiere a que no puede ejecutar más de una función al mismo tiempo), la promesa indica en el código que algo va a pasar en un momento especifico.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejPromise" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforePromise">
        Se utilizaba callback hell que retornaba código difícil de leer.
      </span>
      <span class="ejAfter blind" id="ejAfterPromise">
        const helloPromise = () => {<br/>
          return new Promise((resolve, reject) => {<br/>
            <em class="coment">// *Promise debe escribirse con mayúscula para que sea efectivo.</em>
            <em class="coment">// Retornará una nueva promesa al arrow function con dos parámetros que indicarán si la promesa es aceptada o rechazada.</em><br/>
            if (true) {<br/>
              resolve ( '¡Hey!' );<br/>
              <em class="coment">// Si se cumple la condición se ejecutará el elemento "resolve".</em><br/>
            } else {<br/>
              reject ( '¡Ups!' );<br/>
              <em class="coment">// Si no se cumple la condición se ejecutará el elemento "reject".</em><br/>
            }<br/>
          })<br/>
        }<br/>
        helloPromise()<br/>
        <em class="coment">// Se manda a llamar la función para ejecutar la promesa...</em><br/>
          .then(response => console.log( response ));<br/>
          <em class="coment">// Si se cumple la condición de la promesa descrita en la función, se imprimirá en consola el contenido ¡Hey!</em><br/>
          .catch( error => console.log( error ));<br/>
          <em class="coment">// Si no se cumple la condición de la promesa descrita en la función, se imprimirá en consola el contenido ¡Ups!</em><br/>
      </span>
      <h3>Clases.</h3>
      <p>Permite aplicar la programación orientada a objetos, usando una sintaxis para manejar objetos y la herencia.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejClass" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeClass">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterClass">
        class perrera {<br/>
          <em class="coment">// Se genera una clase.</em><br/>
          constructor() {<br/>
            this.Hembras = 0;<br/>
            this.Machos = 0;<br/>
            <em class="coment">// Se genera un constructor con dos variables en scope global.</em><br/>
          }<br/>
          sum(Hembras, Machos) {<br/>
            <em class="coment">// Se genera un método al que se le pasan las dos variables.</em><br/>
            this.Hembras = Hembras;<br/>
            this.Machos = Machos;<br/>
            <em class="coment">// Se le asignan los valores recibidos por los argumentos a las variables.</em><br/>
            return this.Hembras + this.Machos;<br/>
            <em class="coment">// Se retorna la suma de las dos variables.</em><br/>
          }<br/>
        }<br/>
        const total = new perrera();<br/>
        console.log( total.sum( 2, 2 ) );<br/>
        <em class="coment">// Se llama a la clase con su función "sum" y se le pasan los valores a sumar.</em><br/>
      </span>
      <h3>Módulos (import y export).</h3>
      <p>Permite separar en módulos la lógica de un programa conectando funciones o variables de diferentes archivos a través de exportaciones e importaciones.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejModulo" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="seer" id="ejBeforeModulo">
        <span class="ejBefore">
          function dabaDu() {<br/>
            return 'Yaba daba du';<br/>
          }<br/>
          module.exports = dabaDu;<br/>
          <em class="coment">// Se exporta la función para q se use en otro archivo cuando se necesite.</em><br/>
        </span>
        <span class="ejBefore">
          const dabaDu = require('<u>directorio</u>');<br/>
          <em class="coment">// Importa la función "dabaDu" desde un documento externo, para esto se debe colocar la ruta del documento que generalmente es "./module" ya que los módulos se guardan en una carpeta contigua a la carpeta de los scripts en un proyecto.</em><br/>
          console.log(dabaDu());<br/>
          <em class="coment">// Después se puede utilizar la función o variable como si fuera parte del código.</em><br/>
        </span>
      </span>
      <span class="blind" id="ejAfterModulo">
        <span class="ejAfter">
          export const dabaDu = () => {<br/>
            return '¡Yaba daba du!';<br/>
          }<br/>
          export const enfado = '¡Enano!';<br/>
          <em class="coment">// Se exportan las funciones para q se usen en otro archivo cuando se necesiten.</em><br/>
        </span>
        <span class="ejAfter">
          import { dabaDu, enfado as enano } from '<u>directorio</u>';<br/>
          <em class="coment">// Importa las funciones y variables que se requieran (pueden ser apodadas como en el caso de "enfado") desde un documento externo, para esto se debe colocar la ruta del documento que generalmente es "./module" ya que los modulos se guardan en una carpeta contigua a la carpeta de los scripts en un proyecto.</em><br/>
          console.log(dabaDu());<br/>
          console.log(enano);<br/>
          <em class="coment">// Después se pueden utilizar las funciones o variables como si fueran parte del código.</em><br/><br/>
          <em class="coment">// Se puede importar todo con: import * as todo from './module';</em><br/>
          <em class="coment">// Y se utiliza: todo.dabaDu(); todo.enano;</em>
        </span>
      </span>
      <h3>Generadores</h3>
      <p>Permite retornar una serie de valores según el algoritmo definido a través de una función especial.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejGenerator" class="falseTrue">
        <b>ES6</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeGenerator">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterGenerator">
        function* congratulation ( ) {<br/>
          <em class="coment">// Se coloca un asterisco para indicar que es un generador.</em><br/>
          <em class="coment">// Según la composición del algoritmo es como se retornarán los valores.</em><br/>
          if ( true ) {<br/>
            yield 'Happy ';<br/>
            <em class="coment">// yield permite retornar un valor y guardarlo de forma interna.</em><br/>
          }<br/>
          if ( true ) {<br/>
            yield 'Birthday';<br/>
        } }<br/>
        const generatorCongrat = congratulation();<br/>
        <em class="coment">// Se ejecutará el generador a travez de una constante.</em><br/>
        console.log(generatorCongrat.next().value);<br/>
        <em class="coment">// next permite utilizar el valor del primer yield.</em><br/>
        console.log(generatorCongrat.next().value);<br/>
        <em class="coment">// El primer yield guarda en memoria interna que ha sido usado y cuando se utiliza otro next le permite al segundo yield mandar su valor.</em><br/>
        console.log(generatorCongrat.next().value);<br/>
        <em class="coment">// Cuando ya no hay yields con valores disponibles se obtiene un "undefined".</em><br/>
      </span>
      <h3>Include.</h3>
      <p>Permite saber si hay un elemento dentro de un arreglo o un string</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejInclude" class="falseTrue">
        <b>ES7</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeInclude">
        Antes se utilizaba indexOf y un código amplio.
      </span>
      <span class="ejAfter blind" id="ejAfterInclude">
        let numbers = [1, 2, 3, 4, 5];<br/>
        if ( numbers.includes( 8 ) ) {<br/>
          console.log('El array incluye ése número.')<br/>
        } else {<br/>
        console.log('El array no incluye ése número.')<br/>
      }
      </span>
      <h3>Operaciones con exponencial.</h3>
      <p>Permite elevar un numero a la enésima potencia.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejExponente" class="falseTrue">
        <b>ES7</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeExponente">
        Antes se tenía que utilizar la librería Math.
      </span>
      <span class="ejAfter blind" id="ejAfterExponente">
        let base = 5;<br/>
        let esponente = 3;<br/>
        let resultado = base ** exponente;<br/>
        console.log ( resultado );<br/>
        <em class="coment">// imprime el resultado de 5<sup>3</sup>: 125</em>
      </span>
      <h3>Object con entries.</h3>
      <p>Permite obtener una matriz de pares propios de una propiedad numerable [key, value] de un objeto dado.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejOEntries" class="falseTrue">
        <b>ES8</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeOEntries">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterOEntries">
        const knd = {<br/>
        planeación: 'Nigel',<br/>
        tecnología: 'Hoagle',<br/>
        táctica: 'Kuki',<br/>
        ejecución: 'Wallabee',<br/>
        supervición: 'Abigail',<br/>
        }<br/>
        const entradas = Object.entries(knd);<br/>
        console.log( entradas );<br/>
        <em class="coment">// Devuelve arreglos con strings:<br/>
        [<br/>
        [ 'planeación', 'Nigel' ],<br/>
        [ 'tecnología', 'Hoagle' ],<br/>
        ...<br/>
        ]<br/></em>
      </span>
      <h3>Object con values.</h3>
      <p>Permite obtener un array que contenga los valores de las propiedades numerables de un objeto dado</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejOValues" class="falseTrue">
        <b>ES8</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeOValues">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterOValues">
        const knd = {<br/>
          planeación: 'Nigel',<br/>
          tecnología: 'Hoagle',<br/>
          táctica: 'Kuki',<br/>
          ejecución: 'Wallabee',<br/>
          supervición: 'Abigail',<br/>
          }<br/>
          const valores = Object.values(knd);<br/>
          console.log( valores );<br/>
          <em class="coment">// Devuelve un arreglo con strings:<br/>
          [ 'Nigel', 'Hoagle', 'Kuki', ... ]</em>
      </span>
      <h3>String con padStart y padEnd.</h3>
      <p>Permite agregar un carácter al inicio o al final de un string.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejPadSE" class="falseTrue">
        <b>ES8</b>
      </form>
      <span class="ejBefore seer" id="ejBeforePadSE">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterPadSE">
        const frase = 'Hi Ho Silver'; <em class="coment">// Tiene 12 carácteres.</em>
        console.log(frase.padStart(15, '¡¡¡')); <em class="coment">// A los 12 carácteres se les agrega 3 y en total serán 15.</em>
        console.log(frase.padEnd(15, '!!!')); <em class="coment">// A los 12 carácteres se les agrega 3 y en total serán 15.</em>
      </span>
      <h3>Trailing commas para objetos.</h3>
      <p>Permite dejar una coma “volando” dentro de un objeto sin necesidad de añadir un nuevo valor y no se marcará un error en el código. Se utiliza para evitar errores al añadir nuevos valores al objeto o función.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejComas" class="falseTrue">
        <b>ES8</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeComas">
        let manadas = {<br/>
          cerdos: 'piara',
          perros: 'jauría',
          vacas: 'vacada',
          ovejas: 'rebaño',
          cabras: 'rebaño',
        }<br/>
        <em class="coment">// en ES5 solo se utilizaba en arrays y objetos.</em><br/>
      </span>
      <span class="ejAfter blind" id="ejAfterComas">
        function manadas( animal1, animal2, )<br/>
        {...}<br/>
        <em class="coment">// en ES8 se utiliza también en parámetros y argumentos de funciones y en clases.</em><br/>
      </span>
      <h3>Async await</h3>
      <p>La expresión await provoca que la ejecución de una función async sea pausada hasta que una Promise sea terminada o rechazada, y regresa a la ejecución de la función async después de que termine. Al regreso de la ejecución, el valor de la expresión await es la regresada por una promesa terminada.</p>
      <p>Si la Promise es rechazada, el valor de la expresión await tendrá el valor de rechazo.</p>
      <p>Si el valor de la expresión seguida del operador await no es una promesa, será convertido a una resolved Promise.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejAsync" class="falseTrue">
        <b>ES8</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeAsync">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterAsync">
        const helloWorld = () => {<br/>
          return new Promise (( resolve, reject ) => {<br/>
            <em class="coment">// Se crea una promesa dentro de la función con un estado de aceptación y uno de rechazo.</em><br/>
            ( true )<br/>
            <em class="coment">// Se crea una condicional para identificar si se detona la aceptación o el rechazo.</em><br/>
            ? setTimeout ( ( ) => resolve ( 'Hello World' ), 3000 );<br/>
            <em class="coment">// Si se cumple se ejecuta una función que retarda 3 segundos la aceptación.</em><br/>
            : reject ( new Error ( 'Test Error' ) );<br/>
            <em class="coment">// Si no se cumple se ejecuta el rechazo.</em><br/>
          });<br/>
        }<br/>
        <hr/>
        const helloAsync = async ( ) => {<br/>
          <em class="coment">// Se crea una constante con una función que utiliza la palabra reservada "async" para indicar que se trata de un async que utilizará awaits.</em><br/>
          const whatsUp = await helloWorld ( );<br/>
          console.log ( whatsUp );<br/>
          <em class="coment">// Se ejecuta la función "helloWorld" con un await para que se verifique si se acepta o rechaza la promesa.</em><br/>
        }<br/>
        helloAsync ( );<br/>
        <em class="coment">// Se ejecuta la función de async.</em>
        <hr/>
        <em class="coment">// También se puede usar un try-catch en un async para atrapar los errores y poder manejarlos.</em><br/>
        const anotherFunction = async ( ) => {<br/>
          <em class="coment">// Se crea la función indicando la palabra reservada async para indicar que se utilizarán awaits.</em><br/>
          try {<br/>
            const whatsUp = await helloWorld ( );<br/>
            console.log ( whatsUp );<br/>
            <em class="coment">// Se indica al código que trate (try) de ejecutar el await con la promesa.</em><br/>
          } catch ( errorBye ) {<br/>
            console.log ( errorBye );<br/>
            <em class="coment">// Si no se cumple la promesa y se rechaza se ejecutará eta parte y mostrará el error con los datos explicados de la causa.</em><br/>
        } }<br/>
        anotherFunction ( );<br/>
        <em class="coment">// Se manda a llamar la función para ejecutarla.</em>
      </span>
      <h3>Operador de reposo (Spread operator).</h3>
      <p>Permite extraer las propiedades de un objeto que aún no se ha construido.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejReposo" class="falseTrue">
        <b>ES9</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeReposo">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterReposo">
        const obj = {<br/>
          name: 'Orange',<br/>
          color: 'orange',<br/>
          provenance: 'tree',<br/>
        }<br/>
        let { name, ...all } = obj;<br/>
        <em class="coment">// Se extraerá todo el contenido (...all) con referencia al dato "name", todo esto se aplicará al objeto "obj".</em><br/>
        console.log( name, all );<br/>
        <em class="coment">// Imprime: Orange { color: 'orange', provenance: 'tree' }</em>
        <hr/>
        let { provenance, ...all } = obj;<br/>
        <em class="coment">// Se extraerá todo el contenido (...all) con excepción del dato "provenance".</em><br/>
        console.log(all);<br/>
        <em class="coment">// Imprime: { name: 'Orange', color: 'orange' }</em>
      </span>
      <h3>Propiedades de propagación.</h3>
      <p>Permite unir varios elementos de un objeto en otro objeto.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejPPropaga" class="falseTrue">
        <b>ES9</b>
      </form>
      <span class="ejBefore seer" id="ejBeforePPropaga">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterPPropaga">
        const obj1 = {<br/>
          jewelry: 'The Hope Diamond',<br/>
          costNumber: 250000000,<br/>
        }<br/>
        <em class="coment">// Objeto 1 con elementos.</em><br/>
        const obj2 = {<br/>
          ...obj,<br/>
          costText: '250 millions of dollar',<br/>
        }<br/>
        <em class="coment">// Objeto 2 con sus elementos y la adición del objeto 1.</em><br/>
        console.log(obj2);
      </span>
      <h3>Promise.finally</h3>
      <p>Permite saber cuándo ha terminado un llamado y para poder ejecutar una lógica de código.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejFinally" class="falseTrue">
        <b>ES9</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeFinally">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterFinally">
        const food = () => {<br/>
          return new Promise((resolve, reject) => {<br/>
            (true)<br/>
            ? resolve('Food is delicious!');<br/>
            : reject(new Error('Test error'));<br/>
          });<br/>
        }<br/>
        food();<br/>
        .then(response => console.log(response));<br/>
        .catch(error => console.log(error));<br/>
        .finally(() => console.log('Ended'));<br/>
        <em class="coment">// Al correr este código se imprime el mensaje de aprobación y el mensaje de .finally que indica que ya finalizó el código.</em>
      </span>
      <h3>Regex.</h3>
      <p>Permite agrupar bloques del Regex y poder acceder a cada uno de ellos.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejRegex" class="falseTrue">
        <b>ES9</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeRegex">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterRegex">
        const regexData = /([0-9]{4})-([0-9]{2})-([0-9]{2})/;<br/>
        <em class="coment">// Se crea una constante para poder manejar el Regex.</em><br/>
        const match = regexData.exec('2021-08-23');<br/>
        const year = match[1];<br/>
        <em class="coment">// Apunta al primer bloque del grupo del Regex y ese contenido se guardará en la constante "year".</em><br/>
        const month = match[2];<br/>
        <em class="coment">// Apunta al segundo bloque del grupo del Regex y guarda su contenido.</em><br/>
        const day = match[3];<br/>
        <em class="coment">// Apunta al tercer bloque y guarda su contenido.</em>
        console.log(year, month, day);
      </span>
      <h3>Flat.</h3>
      <p>Permite aplanar arreglos por medio de la función array.flat(nivel _de_profundidad)</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejFlat" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeFlat">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterFlat">
        let array = [1,2,3, [1,2,3, [1,2,3]]];<br/>
        console.log(array.flat());<br/>
        <em class="coment">// Muestra la profundidad por default que es 1:<br/> [ 1, 2, 3, 1, 2, 3, [ 1, 2, 3 ] ]</em></br>
        console.log(array.flat(2));<br/>
        <em class="coment">// Muestra la profundidad de nivel 2:<br/> [<br/> 1, 2, 3, 1, 2,<br/> 3, 1, 2, 3<br/> ]</em>
      </span>
      <h3>FlatMap.</h3>
      <p>Permite mapear cada elemento, pasarles una función y aplanar el resultado por medio de la función array.flatMap()</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejFlatMap" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeFlatMap">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterFlatMap">
        let array = [1,2,3,4,5];<br/>
        console.log(array.flatMap(value => [value, value * 2]));<br/>
        <em class="coment">[<br/> 1, 2, 2, 4, 3,<br/> 6, 4, 8, 5, 10<br/>]</em>
      </span>
      <h3>Trim Start/End.</h3>
      <p>Permite quitar los espacios al inicio o al final dependiendo de la funciona por medio de la función String.trimStart() o String.trimEnd()</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejTrim" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeTrim">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterTrim">
        let space = '     ^u^     ';<br/>
        console.log('¬_¬' + space + 'L_L');<br/>
        <em class="coment">// Imprime: ¬_¬     ^u^     L_L</em><br/>
        console.log('¬_¬' + space.trimStart() + 'L_L');<br/>
        <em class="coment">// Imprime: ¬_¬^u^     L_L</em><br/>
        console.log('¬_¬' + space.trimEnd() + 'L_L');<br/>
        <em class="coment">// Imprime: ¬_¬     ^u^L_L</em>
      </span>
      <h3>Try/Catch</h3>
      <p>Permite utilizar catch sin necesidad de especificar el elemento "error" como argumento.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejTCatch" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeTCatch">
        try {<br/>
        ...<br/>
        } catch(error) {<br/>
        error<br/>
        }<br/>
      </span>
      <span class="ejAfter blind" id="ejAfterTCatch">
        try {<br/>
          ...<br/>
          } catch {<br/>
          error<br/>
          }
      </span>
      <h3>FromEntries.</h3>
      <p>Permite transformar una matriz clave/valor en un objeto por medio de la función object.fromEntries(). Lo inverso a Object.entries() que convierte un objeto en una matriz clave/valor.</p>
      <p>Es de ayuda cuando se trabaja con arreglos que se quieren transformar en objetos o viceversa.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejFEntries" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeFEntries">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterFEntries">
        let entries [["name", "alex"], ["age", 21]];<br/>
        console.log(Object.fromEntries(entries));<br/>
        <em class="coment">// { name: 'alex', age: 21 }</em>
      </span>
      <h3>Symbol.</h3>
      <p>Permite acceder a la descripción de un elemento de tipo símbolo por medio de la función symbol.prototype.description.</p>
      <form action="#" class="ejFormato">
        <b>antes</b>
        <input type="range" min="0" max="1" value="0" id="ejSymbol" class="falseTrue">
        <b>ES10</b>
      </form>
      <span class="ejBefore seer" id="ejBeforeSymbol">
        ...
      </span>
      <span class="ejAfter blind" id="ejAfterSymbol">
        let mySymbol = 'My Symbol';<br/>
        let symbol = Symbol(mySymbol);<br/>
        <em class="coment">// La variable "symbol" se le adiciona el tipo symbol y la variable obtiene una descripción.</em><br/>
        console.log(symbol.description);<br/>
        <em class="coment">// Se imprime la descripción de la variable symbol que es: My Symbol</em>
      </span>
    </div>
  </div>
  <footer>
    <h3>Referencias:</h3>
    <p>
      <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas" target="blank">Trailing commas.</a><br/>
      <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">Global objects.</a><br/>
      <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/await" target="_blank">Await.</a><br/>
      <a href="https://platzi.com/tutoriales/1789-asincronismo-js/5063-las-promesas-y-async-await-logicamente-no-son-iguales-y-te-explico-el-porque/" target="_blank">Promesas vs Async.</a><br/>
      <a href="https://millionconverter.com/millionTobillion/" target="_blank">Escala numérica.</a><br/>
    </p>
  </footer>
  <script src="../Js/programajs9.js"></script>
</body>
</html>
