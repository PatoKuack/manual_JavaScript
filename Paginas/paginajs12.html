<!DOCTYPE html>
<html lang="es">
<head>
  <!-- No guardar cache en navegadores -->
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="expires" content="0">
  <!-- ------------------- -->
  <!-- <link rel="stylesheet" href="../Estilos/stylejs1.css">
  <link rel="stylesheet" href="../Estilos/stylejs2.css"> -->
  <link rel="stylesheet" href="../Estilos/stylejs11.css">
  <link rel="stylesheet" href="../Estilos/stylejs12.css">
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ECMAScript6+</title>
</head>
<body>
  <section class="container">
    <h1>ECMAScript6+</h1>
    <p>ECMA es una institución que dicta estándares o funcionalidades que deben adaptarse o añadirse a los engines de Js. Puesto que Js es un lenguaje interpretado y con muchos motores que lo interpretan/compilan, se vio la necesidad de hacer un estándar que todos esos motores siguieran, para tener consistencia en nuestro desarrollo a lo largo de todos los navegadores.</p>
    <p>ECMAScript es la especificación del lenguaje JavaScript propuesto por ECMA Internacional.</p>
    <p>JavaScript es un lenguaje de programación o de secuencias de comandos que permite implementar funciones complejas en páginas web, este lenguaje utiliza las especificaciones propuestas por ECMA, que van siendo añadidas a ECMAScript cada año a partir del 2015, cuando fue lanzado ES6.</p>
    <p>La especificación ECMA-262 de ECMASCRIPT es un manual de más de 800 páginas que muestra todo acerca del lenguaje JavaScript.</p>
  </section>
  <section class="container">
    <p>En ECMAScript 6 se agregaron las siguientes características:</p>
    <h2>Parámetros por defecto.</h2>
    <p>Permiten establecer los valores por defecto que se le pasan a una función.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejDefault" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeDefault">
      function newFunction(name, age){<br/>
      var name = name || 'Fulanito';<br/>
      var age = age || 18;<br/>
      console.log(name, age);<br/>
      }<br/>
      newfunction(); <em class="coment">// imprime los valore por defecto: Fulanito 18</em><br/>
      newfunction('Luis', 22); <em class="coment">// imprime los valores establecidos: Luis 22</em><br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterDefault">
      function newFunction(name = 'Fulanito', age = 18){<br/>
      console.log(name, age);<br/>
      }<br/>
      newfunction(); <em class="coment">// imprime los valore por defecto: Fulanito 18</em><br/>
      newfunction('Luis', 22); <em class="coment">// imprime los valores establecidos: Luis 22</em><br/>
    </div>
    <h2>Template literals.</h2>
    <p>Permiten separar o unir varios elementos.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejLiteral" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeLiteral">
      let im = "Soy";<br/>
      let a = "un";<br/>
      let goofyGoober = "cacahuate";<br/>
      let epicPhrase = im + ' ' + a + ' ' + goofyGoober; <em class="coment">// concatenación de valores con el signo +.</em><br/>
      console.log(epicPhrase);
    </div>
    <div class="eg ejAfter blind" id="ejAfterLiteral">
      let im = "Soy";<br/>
      let a = "un";<br/>
      let goofyGoober = "cacahuate";<br/>
      let epicPhrase = `${im} ${a} ${goofyGoober}`; <em class="coment">// concatenación de valores con template literals ``.</em><br/>
      console.log(epicPhrase);
    </div>
    <h2>Multilínea en strings.</h2>
    <p>Permite agregar saltos de línea en las declaraciones de tipo string.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejMultilinea" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeMultilinea">
      let mathProblem = "Si le das la mitad de tu manzana a un amigo, ¿Qué tienes? \n u... un amigo"; <em class="coment">// Se requiere un slash invertido con una ene para que se produzca un salto de línea en el string.</em><br/>
      console.log(mathProblem);<br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterMultilinea">
      let mathProblem = `Si le das la mitad de tu manzana a un amigo, ¿Qué tienes?<br/>
      u... un amigo`; <em class="coment">// Solo se requiere un salto de línea para que se visualice en el string.</em><br/>
      console.log(mathProblem);
    </div>
    <h2>Restructuración de elementos.</h2>
    <p>Permite acceder y restructurar elementos de un objeto.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejRestruct" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeRestruct">
      let person = {<br/>
        'name': 'oscar';<br/>
        'age':  '32';<br/>
      }<br/>
      console.log(person.name, person.age); <em class="coment">// Imprime los elementos de una forma un poco compleja, pero con un método fácil de recordar.</em>
    </div>
    <div class="eg ejAfter blind" id="ejAfterRestruct">
      let person = {<br/>
        'name': 'oscar';<br/>
        'age':  '32';<br/>
      }<br/>
      let { name, age } = person;<br/>
      console.log(name, age); <em class="coment">// Imprime los elementos de una forma menos compleja, pero con un método más difícil de recordar.</em>
    </div>
    <h2>Operador de propagación.</h2>
    <p>Permite importar los elementos de un objeto.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejOPropaga" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeOPropaga">
      let team1 = ['Vilma', 'Scooby', 'Shaggy'];<br/>
      let team2 = ['Daphne', 'Fred'];<br/>
      let mistery = ['Scrappy', 'Vilma', 'Scooby', 'Shaggy', 'Daphne', 'Fred']; <em class="coment">// Conjunto de los equipos de una forma laboriosa.</em><br/>
      console.log(mistery);
    </div>
    <div class="eg ejAfter blind" id="ejAfterOPropaga">
      let team1 = ['Vilma', 'Scooby', 'Shaggy'];<br/>
      let team2 = ['Daphne', 'Fred'];<br/>
      let mistery = ['Scrappy', ...team1, ...team2]; <em class="coment">// Conjunto de los equipos de una forma más fácil.</em><br/>
      console.log(mistery);
    </div>
    <h2>Propiedad de objetos mejorada.</h2>
    <p>Permite trabajar con objetos de una forma más fácil al querer asignarles valores a sus elementos.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejObjeto" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeObjeto">
      let monster = 'Ickis';<br/>
      let reportCard = 7;<br/>
      school = { monster: monster, reportCard: reportCard }; <em class="coment">// Establece elementos para un objeto tomando variables para ello.</em><br/>
      console.log(school);<br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterObjeto">
      let monster = 'Ickis';<br/>
      let reportCard = 7;<br/>
      school = { monster, reportCard }; <em class="coment">// Establece elementos para un objeto tomando variables para ello de una forma simple.</em><br/>
      console.log(school);<br/>
    </div>
    <h2>Arrow Function / Funciones de flecha.</h2>
    <p>Permite tener una sintaxis más reducida y un <b>this</b> no vinculable.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejArrow" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeArrow">
      const names = [<br/>
        { name: 'Oscar', age: 32}<br/>
        { name: 'Brandon', age: 22}<br/>
      ]<br/>
      let listOfNames = names.map (<br/>
        function ( item ) {<br/>
          console.log( item.name ); <em class="coment">// Imprime cada uno de los nombres del objeto.</em><br/>
      } )<br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterArrow">
      const names = [<br/>
        { name: 'Oscar', age: 32}<br/>
        { name: 'Brandon', age: 22}<br/>
      ]<br/>
      let listOfNames = names.map ( item => {<br/>
        console.log( item.name ); <em class="coment">// Se establece como una función anónima que retornará cada uno de los nombres del objeto.</em><br/>
      } )<br/>
    </div>
    <h2>Promesas.</h2>
    <p>Permite trabajar con el asincronismo de JavaScript (asincronismo se refiere a que no puede ejecutar más de una función al mismo tiempo), la promesa indica en el código que algo va a pasar en un momento especifico.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejPromise" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforePromise">
      Se utilizaba callback hell que retornaba código difícil de leer.
    </div>
    <div class="eg ejAfter blind" id="ejAfterPromise">
      const helloPromise = () => {<br/>
        return new Promise((resolve, reject) => {<br/>
          <em class="coment">// *Promise debe escribirse con mayúscula para que sea efectivo.</em>
          <em class="coment">// Retornará una nueva promesa al arrow function con dos parámetros que indicarán si la promesa es aceptada o rechazada.</em><br/>
          if (true) {<br/>
            resolve ( '¡Hey!' );<br/>
            <em class="coment">// Si se cumple la condición se ejecutará el elemento "resolve".</em><br/>
          } else {<br/>
            reject ( '¡Ups!' );<br/>
            <em class="coment">// Si no se cumple la condición se ejecutará el elemento "reject".</em><br/>
          }<br/>
        })<br/>
      }<br/>
      helloPromise()<br/>
      <em class="coment">// Se manda a llamar la función para ejecutar la promesa...</em><br/>
        .then(response => console.log( response ));<br/>
        <em class="coment">// Si se cumple la condición de la promesa descrita en la función, se imprimirá en consola el contenido ¡Hey!</em><br/>
        .catch( error => console.log( error ));<br/>
        <em class="coment">// Si no se cumple la condición de la promesa descrita en la función, se imprimirá en consola el contenido ¡Ups!</em><br/>
    </div>
    <h2>Clases.</h2>
    <p>Permite aplicar la programación orientada a objetos, usando una sintaxis para manejar objetos y la herencia.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejClass" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeClass">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterClass">
      class perrera {<br/>
        <em class="coment">// Se genera una clase.</em><br/>
        constructor() {<br/>
          this.Hembras = 0;<br/>
          this.Machos = 0;<br/>
          <em class="coment">// Se genera un constructor con dos variables en scope global.</em><br/>
        }<br/>
        sum(Hembras, Machos) {<br/>
          <em class="coment">// Se genera un método al que se le pasan las dos variables.</em><br/>
          this.Hembras = Hembras;<br/>
          this.Machos = Machos;<br/>
          <em class="coment">// Se le asignan los valores recibidos por los argumentos a las variables.</em><br/>
          return this.Hembras + this.Machos;<br/>
          <em class="coment">// Se retorna la suma de las dos variables.</em><br/>
        }<br/>
      }<br/>
      const total = new perrera();<br/>
      console.log( total.sum( 2, 2 ) );<br/>
      <em class="coment">// Se llama a la clase con su función "sum" y se le pasan los valores a sumar.</em><br/>
    </div>
    <h2>Módulos (import y export).</h2>
    <p>Permite separar en módulos la lógica de un programa conectando funciones o variables de diferentes archivos a través de exportaciones e importaciones.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejModulo" class="falseTrue">
      <b>ES6</b>
    </form>
    <span class="seer" id="ejBeforeModulo">
      <div class="eg ejBefore">
        function dabaDu() {<br/>
          return 'Yaba daba du';<br/>
        }<br/>
        module.exports = dabaDu;<br/>
        <em class="coment">// Se exporta la función para q se use en otro archivo cuando se necesite.</em><br/>
      </div>
      <div class="eg ejBefore">
        const dabaDu = require('<u>directorio</u>');<br/>
        <em class="coment">// Importa la función "dabaDu" desde un documento externo, para esto se debe colocar la ruta del documento que generalmente es "./module" ya que los módulos se guardan en una carpeta contigua a la carpeta de los scripts en un proyecto.</em><br/>
        console.log(dabaDu());<br/>
        <em class="coment">// Después se puede utilizar la función o variable como si fuera parte del código.</em><br/>
      </div>
    </span>
    <span class="blind" id="ejAfterModulo">
      <div class="eg ejAfter">
        export const dabaDu = () => {<br/>
          return '¡Yaba daba du!';<br/>
        }<br/>
        export const enfado = '¡Enano!';<br/>
        <em class="coment">// Se exportan las funciones para q se usen en otro archivo cuando se necesiten.</em><br/>
      </div>
      <div class="eg ejAfter">
        import { dabaDu, enfado as enano } from '<u>directorio</u>';<br/>
        <em class="coment">// Importa las funciones y variables que se requieran (pueden ser apodadas como en el caso de "enfado") desde un documento externo, para esto se debe colocar la ruta del documento que generalmente es "./module" ya que los modulos se guardan en una carpeta contigua a la carpeta de los scripts en un proyecto.</em><br/>
        console.log(dabaDu());<br/>
        console.log(enano);<br/>
        <em class="coment">// Después se pueden utilizar las funciones o variables como si fueran parte del código.</em><br/><br/>
        <em class="coment">// Se puede importar todo con: import * as todo from './module';</em><br/>
        <em class="coment">// Y se utiliza: todo.dabaDu(); todo.enano;</em>
      </div>
    </span>
    <h2>Generadores</h2>
    <p>Permite retornar una serie de valores según el algoritmo definido a través de una función especial.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejGenerator" class="falseTrue">
      <b>ES6</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeGenerator">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterGenerator">
      function* congratulation ( ) {<br/>
        <em class="coment">// Se coloca un asterisco para indicar que es un generador.</em><br/>
        <em class="coment">// Según la composición del algoritmo es como se retornarán los valores.</em><br/>
        if ( true ) {<br/>
          yield 'Happy ';<br/>
          <em class="coment">// yield permite retornar un valor y guardarlo de forma interna.</em><br/>
        }<br/>
        if ( true ) {<br/>
          yield 'Birthday';<br/>
      } }<br/>
      const generatorCongrat = congratulation();<br/>
      <em class="coment">// Se ejecutará el generador a travez de una constante.</em><br/>
      console.log(generatorCongrat.next().value);<br/>
      <em class="coment">// next permite utilizar el valor del primer yield.</em><br/>
      console.log(generatorCongrat.next().value);<br/>
      <em class="coment">// El primer yield guarda en memoria interna que ha sido usado y cuando se utiliza otro next le permite al segundo yield mandar su valor.</em><br/>
      console.log(generatorCongrat.next().value);<br/>
      <em class="coment">// Cuando ya no hay yields con valores disponibles se obtiene un "undefined".</em><br/>
    </div>
    <h2>Include.</h2>
    <p>Permite saber si hay un elemento dentro de un arreglo o un string</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejInclude" class="falseTrue">
      <b>ES7</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeInclude">
      Antes se utilizaba indexOf y un código amplio.
    </div>
    <div class="eg ejAfter blind" id="ejAfterInclude">
      let numbers = [1, 2, 3, 4, 5];<br/>
      if ( numbers.includes( 8 ) ) {<br/>
        console.log('El array incluye ése número.')<br/>
      } else {<br/>
      console.log('El array no incluye ése número.')<br/>
    }
    </div>
    <h2>Operaciones con exponencial.</h2>
    <p>Permite elevar un numero a la enésima potencia.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejExponente" class="falseTrue">
      <b>ES7</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeExponente">
      Antes se tenía que utilizar la librería Math.
    </div>
    <div class="eg ejAfter blind" id="ejAfterExponente">
      let base = 5;<br/>
      let esponente = 3;<br/>
      let resultado = base ** exponente;<br/>
      console.log ( resultado );<br/>
      <em class="coment">// imprime el resultado de 5<sup>3</sup>: 125</em>
    </div>
    <h2>Object con entries.</h2>
    <p>Permite obtener una matriz de pares propios de una propiedad numerable [key, value] de un objeto dado.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejOEntries" class="falseTrue">
      <b>ES8</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeOEntries">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterOEntries">
      const knd = {<br/>
      planeación: 'Nigel',<br/>
      tecnología: 'Hoagle',<br/>
      táctica: 'Kuki',<br/>
      ejecución: 'Wallabee',<br/>
      supervición: 'Abigail',<br/>
      }<br/>
      const entradas = Object.entries(knd);<br/>
      console.log( entradas );<br/>
      <em class="coment">// Devuelve arreglos con strings:<br/>
      [<br/>
      [ 'planeación', 'Nigel' ],<br/>
      [ 'tecnología', 'Hoagle' ],<br/>
      ...<br/>
      ]<br/></em>
    </div>
    <h2>Object con values.</h2>
    <p>Permite obtener un array que contenga los valores de las propiedades numerables de un objeto dado</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejOValues" class="falseTrue">
      <b>ES8</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeOValues">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterOValues">
      const knd = {<br/>
        planeación: 'Nigel',<br/>
        tecnología: 'Hoagle',<br/>
        táctica: 'Kuki',<br/>
        ejecución: 'Wallabee',<br/>
        supervición: 'Abigail',<br/>
        }<br/>
        const valores = Object.values(knd);<br/>
        console.log( valores );<br/>
        <em class="coment">// Devuelve un arreglo con strings:<br/>
        [ 'Nigel', 'Hoagle', 'Kuki', ... ]</em>
    </div>
    <h2>String con padStart y padEnd.</h2>
    <p>Permite agregar un carácter al inicio o al final de un string.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejPadSE" class="falseTrue">
      <b>ES8</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforePadSE">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterPadSE">
      const frase = 'Hi Ho Silver'; <em class="coment">// Tiene 12 carácteres.</em>
      console.log(frase.padStart(15, '¡¡¡')); <em class="coment">// A los 12 carácteres se les agrega 3 y en total serán 15.</em>
      console.log(frase.padEnd(15, '!!!')); <em class="coment">// A los 12 carácteres se les agrega 3 y en total serán 15.</em>
    </div>
    <h2>Trailing commas para objetos.</h2>
    <p>Permite dejar una coma “volando” dentro de un objeto sin necesidad de añadir un nuevo valor y no se marcará un error en el código. Se utiliza para evitar errores al añadir nuevos valores al objeto o función.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejComas" class="falseTrue">
      <b>ES8</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeComas">
      let manadas = {<br/>
        cerdos: 'piara',
        perros: 'jauría',
        vacas: 'vacada',
        ovejas: 'rebaño',
        cabras: 'rebaño',
      }<br/>
      <em class="coment">// en ES5 solo se utilizaba en arrays y objetos.</em><br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterComas">
      function manadas( animal1, animal2, )<br/>
      {...}<br/>
      <em class="coment">// en ES8 se utiliza también en parámetros y argumentos de funciones y en clases.</em><br/>
    </div>
    <h2>Async await</h2>
    <p>La expresión await provoca que la ejecución de una función async sea pausada hasta que una Promise sea terminada o rechazada, y regresa a la ejecución de la función async después de que termine. Al regreso de la ejecución, el valor de la expresión await es la regresada por una promesa terminada.</p>
    <p>Si la Promise es rechazada, el valor de la expresión await tendrá el valor de rechazo.</p>
    <p>Si el valor de la expresión seguida del operador await no es una promesa, será convertido a una resolved Promise.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejAsync" class="falseTrue">
      <b>ES8</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeAsync">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterAsync">
      const helloWorld = () => {<br/>
        return new Promise (( resolve, reject ) => {<br/>
          <em class="coment">// Se crea una promesa dentro de la función con un estado de aceptación y uno de rechazo.</em><br/>
          ( true )<br/>
          <em class="coment">// Se crea una condicional para identificar si se detona la aceptación o el rechazo.</em><br/>
          ? setTimeout ( ( ) => resolve ( 'Hello World' ), 3000 );<br/>
          <em class="coment">// Si se cumple se ejecuta una función que retarda 3 segundos la aceptación.</em><br/>
          : reject ( new Error ( 'Test Error' ) );<br/>
          <em class="coment">// Si no se cumple se ejecuta el rechazo.</em><br/>
        });<br/>
      }<br/>
      <hr/>
      const helloAsync = async ( ) => {<br/>
        <em class="coment">// Se crea una constante con una función que utiliza la palabra reservada "async" para indicar que se trata de un async que utilizará awaits.</em><br/>
        const whatsUp = await helloWorld ( );<br/>
        console.log ( whatsUp );<br/>
        <em class="coment">// Se ejecuta la función "helloWorld" con un await para que se verifique si se acepta o rechaza la promesa.</em><br/>
      }<br/>
      helloAsync ( );<br/>
      <em class="coment">// Se ejecuta la función de async.</em>
      <hr/>
      <em class="coment">// También se puede usar un try-catch en un async para atrapar los errores y poder manejarlos.</em><br/>
      const anotherFunction = async ( ) => {<br/>
        <em class="coment">// Se crea la función indicando la palabra reservada async para indicar que se utilizarán awaits.</em><br/>
        try {<br/>
          const whatsUp = await helloWorld ( );<br/>
          console.log ( whatsUp );<br/>
          <em class="coment">// Se indica al código que trate (try) de ejecutar el await con la promesa.</em><br/>
        } catch ( errorBye ) {<br/>
          console.log ( errorBye );<br/>
          <em class="coment">// Si no se cumple la promesa y se rechaza se ejecutará eta parte y mostrará el error con los datos explicados de la causa.</em><br/>
      } }<br/>
      anotherFunction ( );<br/>
      <em class="coment">// Se manda a llamar la función para ejecutarla.</em>
    </div>
    <h2>Operador de reposo (Spread operator).</h2>
    <p>Permite extraer las propiedades de un objeto que aún no se ha construido.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejReposo" class="falseTrue">
      <b>ES9</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeReposo">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterReposo">
      const obj = {<br/>
        name: 'Orange',<br/>
        color: 'orange',<br/>
        provenance: 'tree',<br/>
      }<br/>
      let { name, ...all } = obj;<br/>
      <em class="coment">// Se extraerá todo el contenido (...all) con referencia al dato "name", todo esto se aplicará al objeto "obj".</em><br/>
      console.log( name, all );<br/>
      <em class="coment">// Imprime: Orange { color: 'orange', provenance: 'tree' }</em>
      <hr/>
      let { provenance, ...all } = obj;<br/>
      <em class="coment">// Se extraerá todo el contenido (...all) con excepción del dato "provenance".</em><br/>
      console.log(all);<br/>
      <em class="coment">// Imprime: { name: 'Orange', color: 'orange' }</em>
    </div>
    <h2>Propiedades de propagación.</h2>
    <p>Permite unir varios elementos de un objeto en otro objeto.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejPPropaga" class="falseTrue">
      <b>ES9</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforePPropaga">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterPPropaga">
      const obj1 = {<br/>
        jewelry: 'The Hope Diamond',<br/>
        costNumber: 250000000,<br/>
      }<br/>
      <em class="coment">// Objeto 1 con elementos.</em><br/>
      const obj2 = {<br/>
        ...obj,<br/>
        costText: '250 millions of dollar',<br/>
      }<br/>
      <em class="coment">// Objeto 2 con sus elementos y la adición del objeto 1.</em><br/>
      console.log(obj2);
    </div>
    <h2>Promise.finally</h2>
    <p>Permite saber cuándo ha terminado un llamado y para poder ejecutar una lógica de código.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejFinally" class="falseTrue">
      <b>ES9</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeFinally">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterFinally">
      const food = () => {<br/>
        return new Promise((resolve, reject) => {<br/>
          (true)<br/>
          ? resolve('Food is delicious!');<br/>
          : reject(new Error('Test error'));<br/>
        });<br/>
      }<br/>
      food();<br/>
      .then(response => console.log(response));<br/>
      .catch(error => console.log(error));<br/>
      .finally(() => console.log('Ended'));<br/>
      <em class="coment">// Al correr este código se imprime el mensaje de aprobación y el mensaje de .finally que indica que ya finalizó el código.</em>
    </div>
    <h2>Regex.</h2>
    <p>Permite agrupar bloques del Regex y poder acceder a cada uno de ellos.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejRegex" class="falseTrue">
      <b>ES9</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeRegex">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterRegex">
      const regexData = /([0-9]{4})-([0-9]{2})-([0-9]{2})/;<br/>
      <em class="coment">// Se crea una constante para poder manejar el Regex.</em><br/>
      const match = regexData.exec('2021-08-23');<br/>
      const year = match[1];<br/>
      <em class="coment">// Apunta al primer bloque del grupo del Regex y ese contenido se guardará en la constante "year".</em><br/>
      const month = match[2];<br/>
      <em class="coment">// Apunta al segundo bloque del grupo del Regex y guarda su contenido.</em><br/>
      const day = match[3];<br/>
      <em class="coment">// Apunta al tercer bloque y guarda su contenido.</em>
      console.log(year, month, day);
    </div>
    <h2>Flat.</h2>
    <p>Permite aplanar arreglos por medio de la función array.flat(nivel _de_profundidad)</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejFlat" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeFlat">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterFlat">
      let array = [1,2,3, [1,2,3, [1,2,3]]];<br/>
      console.log(array.flat());<br/>
      <em class="coment">// Muestra la profundidad por default que es 1:<br/> [ 1, 2, 3, 1, 2, 3, [ 1, 2, 3 ] ]</em></br>
      console.log(array.flat(2));<br/>
      <em class="coment">// Muestra la profundidad de nivel 2:<br/> [<br/> 1, 2, 3, 1, 2,<br/> 3, 1, 2, 3<br/> ]</em>
    </div>
    <h2>FlatMap.</h2>
    <p>Permite mapear cada elemento, pasarles una función y aplanar el resultado por medio de la función array.flatMap()</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejFlatMap" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeFlatMap">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterFlatMap">
      let array = [1,2,3,4,5];<br/>
      console.log(array.flatMap(value => [value, value * 2]));<br/>
      <em class="coment">[<br/> 1, 2, 2, 4, 3,<br/> 6, 4, 8, 5, 10<br/>]</em>
    </div>
    <h2>Trim Start/End.</h2>
    <p>Permite quitar los espacios al inicio o al final dependiendo de la funciona por medio de la función String.trimStart() o String.trimEnd()</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejTrim" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeTrim">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterTrim">
      let space = '     ^u^     ';<br/>
      console.log('¬_¬' + space + 'L_L');<br/>
      <em class="coment">// Imprime: ¬_¬     ^u^     L_L</em><br/>
      console.log('¬_¬' + space.trimStart() + 'L_L');<br/>
      <em class="coment">// Imprime: ¬_¬^u^     L_L</em><br/>
      console.log('¬_¬' + space.trimEnd() + 'L_L');<br/>
      <em class="coment">// Imprime: ¬_¬     ^u^L_L</em>
    </div>
    <h2>Try/Catch</h2>
    <p>Permite utilizar catch sin necesidad de especificar el elemento "error" como argumento.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejTCatch" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeTCatch">
      try {<br/>
      ...<br/>
      } catch(error) {<br/>
      error<br/>
      }<br/>
    </div>
    <div class="eg ejAfter blind" id="ejAfterTCatch">
      try {<br/>
        ...<br/>
        } catch {<br/>
        error<br/>
        }
    </div>
    <h2>FromEntries.</h2>
    <p>Permite transformar una matriz clave/valor en un objeto por medio de la función object.fromEntries(). Lo inverso a Object.entries() que convierte un objeto en una matriz clave/valor.</p>
    <p>Es de ayuda cuando se trabaja con arreglos que se quieren transformar en objetos o viceversa.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejFEntries" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeFEntries">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterFEntries">
      let entries [["name", "alex"], ["age", 21]];<br/>
      console.log(Object.fromEntries(entries));<br/>
      <em class="coment">// { name: 'alex', age: 21 }</em>
    </div>
    <h2>Symbol.</h2>
    <p>Permite acceder a la descripción de un elemento de tipo símbolo por medio de la función symbol.prototype.description.</p>
    <form action="#" class="ejFormato">
      <b>antes</b>
      <input type="range" min="0" max="1" value="0" id="ejSymbol" class="falseTrue">
      <b>ES10</b>
    </form>
    <div class="eg ejBefore seer" id="ejBeforeSymbol">
      ...
    </div>
    <div class="eg ejAfter blind" id="ejAfterSymbol">
      let mySymbol = 'My Symbol';<br/>
      let symbol = Symbol(mySymbol);<br/>
      <em class="coment">// La variable "symbol" se le adiciona el tipo symbol y la variable obtiene una descripción.</em><br/>
      console.log(symbol.description);<br/>
      <em class="coment">// Se imprime la descripción de la variable symbol que es: My Symbol</em>
    </div>
  </section>
  <footer class="container">
    <h3>Referencias:</h3>
    <p>
      <a class="link" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Trailing_commas" target="blank">Trailing commas.</a><br/>
      <a class="link" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">Global objects.</a><br/>
      <a class="link" href="https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Operators/await" target="_blank">Await.</a><br/>
      <a class="link" href="https://platzi.com/tutoriales/1789-asincronismo-js/5063-las-promesas-y-async-await-logicamente-no-son-iguales-y-te-explico-el-porque/" target="_blank">Promesas vs Async.</a><br/>
      <a class="link" href="https://millionconverter.com/millionTobillion/" target="_blank">Escala numérica.</a><br/>
    </p>
  </footer>
  <script src="../Js/programajs9.js"></script>
</body>
</html>